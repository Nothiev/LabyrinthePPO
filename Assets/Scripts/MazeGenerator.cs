// Assets/Scripts/MazeGenerator.cs
using System.Collections.Generic;
using UnityEngine;

public class MazeGenerator : MonoBehaviour
{
    [Header("Dimensions")]
    public int width = 10;
    public int height = 10;

    [Header("Prefabs")]
    public GameObject floorPrefab;
    public GameObject wallPrefab;

    public Cell[,] grid;

    public int ExitX => width - 2;
    public int ExitY => height - 2;


  void Start()
    {
        GenerateMaze();
    }

    public void GenerateMaze()
    {
        // 1️⃣ Supprime les anciens murs
        foreach (Transform child in transform)
            Destroy(child.gameObject);

        // 2️⃣ Génère la grille + carve
        InitGrid();
        Carve(1, 1);

        // 3️⃣ Ouvre entrée et sortie
        int entryX = 1, exitX = width - 2;
        grid[entryX, 1].WallBottom   = false;
        grid[entryX, 0].WallTop      = false;
        grid[entryX, 0].WallBottom   = false;
        grid[exitX, height - 2].WallTop    = false;
        grid[exitX, height - 1].WallBottom = false;
        grid[exitX, height - 1].WallTop    = false;

        // 4️⃣ Rendu
        RenderMaze();
    }



    void InitGrid()
{
    grid = new Cell[width, height];
    for (int x = 0; x < width; x++)
    for (int y = 0; y < height; y++)
        grid[x, y] = new Cell();
}

void Carve(int x, int y)
{
    grid[x, y].Visited = true;
    foreach (var dir in ShuffleDirections())
    {
        int nx = x + dir.dx, ny = y + dir.dy;
        // n’autorise Carve qu’à l’intérieur du cadre (1..w-2, 1..h-2)
        if (nx > 0 && nx < width  - 1 &&
            ny > 0 && ny < height - 1 &&
           !grid[nx, ny].Visited)
        {
            RemoveWall(grid[x, y], grid[nx, ny], dir);
            Carve(nx, ny);
        }
    }
}

void RenderMaze()
{
    float xOff = -width * 0.5f + 0.5f;
    float yOff = -height * 0.5f + 0.5f;

    for (int x = 0; x < width; x++)
    for (int y = 0; y < height; y++)
    {
        Vector3 basePos = new Vector3(x + xOff, y + yOff, 0);
        var c = grid[x, y];

        // Murs horizontaux
        if (c.WallTop)
            Instantiate(wallPrefab, basePos + Vector3.up * 0.5f,
                        Quaternion.identity, transform);
        if (c.WallBottom)
            Instantiate(wallPrefab, basePos + Vector3.down * 0.5f,
                        Quaternion.identity, transform);

        // Murs verticaux
        if (c.WallLeft)
            Instantiate(wallPrefab, basePos + Vector3.left * 0.5f,
                        Quaternion.Euler(0,0,90), transform);
        if (c.WallRight)
            Instantiate(wallPrefab, basePos + Vector3.right * 0.5f,
                        Quaternion.Euler(0,0,90), transform);
    }
}



    bool InBounds(int x, int y) => x >= 0 && x < width && y >= 0 && y < height;

    void RemoveWall(Cell a, Cell b, (int dx, int dy) dir)
    {
        if (dir.dx == 1)      { a.WallRight = false; b.WallLeft  = false; }
        else if (dir.dx == -1){ a.WallLeft  = false; b.WallRight = false; }
        else if (dir.dy == 1) { a.WallTop   = false; b.WallBottom= false; }
        else if (dir.dy == -1){ a.WallBottom= false; b.WallTop   = false; }
    }

    List<(int dx, int dy)> ShuffleDirections()
    {
        var dirs = new List<(int,int)> { (0,1), (1,0), (0,-1), (-1,0) };
        for (int i = 0; i < dirs.Count; i++)
        {
            int r = Random.Range(i, dirs.Count);
            var tmp = dirs[i]; dirs[i] = dirs[r]; dirs[r] = tmp;
        }
        return dirs;
    }
}
// This script generates a maze using a recursive backtracking algorithm. It initializes a grid of cells, carves passages between them, and then renders the maze using prefabs for floors and walls. The maze is generated by recursively visiting unvisited neighboring cells and removing walls between them. The `ShuffleDirections` method randomizes the order in which directions are explored to create a more varied maze structure.
// The `RenderMaze` method instantiates the floor and wall prefabs at the appropriate positions based on the cell's wall properties. The maze is generated when the script starts, and the dimensions can be adjusted in the Unity Inspector.